from django.shortcuts import get_object_or_404
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .models import BlogTag, Blog
from .serializers import BlogTagSerializer, BlogSerializer, BlogListSerializer
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework import generics
from rest_framework.generics import ListAPIView
from rest_framework.pagination import PageNumberPagination
from user.models import UserAuth
from common.views import CustomJWTAuthentication, IsAdminUser, IsAdminUser
from common.constants import S3_BLOG_BUCKET_NAME
from common.utils.s3_utils import delete_image_from_s3, upload_image_to_s3
from rest_framework.parsers import MultiPartParser, FormParser
from rest_framework.exceptions import PermissionDenied
from misc.models import BlogNotification
from django.db import transaction, DatabaseError
from django.utils import timezone 
from datetime import date
from django.db.models import Q


class BlogTagListCreateView(APIView):
    authentication_classes = [CustomJWTAuthentication]  # or your custom class

    def get_permissions(self):
        if self.request.method == 'GET':
            return [AllowAny()]
        return [IsAdminUser()]

    def get(self, request):
        tags = BlogTag.objects.all()
        serializer = BlogTagSerializer(tags, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)

    def post(self, request):
        serializer = BlogTagSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()  # slug will be auto-generated by model save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    

class BlogTagDetailView(generics.DestroyAPIView):
    queryset = BlogTag.objects.all()
    serializer_class = BlogTagSerializer
    authentication_classes = [CustomJWTAuthentication]

    def get_permissions(self):
        if self.request.method == 'DELETE':
            return [IsAdminUser()]
        return [AllowAny()]


class BlogListCreateAPIView(APIView):
    authentication_classes = [CustomJWTAuthentication]
    permission_classes = [IsAdminUser]

    def get(self, request):
        staff_param = request.query_params.get("staff")
        print("blog list create staff_param:", staff_param)
        blogs = None
        if staff_param is not None:
            if staff_param.lower() == "true":
                blogs = Blog.objects.filter(user__is_staff=True).defer('content').order_by('-created_at')
            elif staff_param.lower() == "false":
                blogs = Blog.objects.filter(user__is_staff=False).defer('content').order_by('-created_at')
            else:
                return Response(
                    {"error": "Invalid value for 'staff' parameter. Use 'true' or 'false'."},
                    status=status.HTTP_400_BAD_REQUEST
                )
        else:
            blogs = Blog.objects.all().defer('content').order_by('-created_at')

        # blogs = Blog.objects.all().defer('content').order_by('-created_at')
        serializer = BlogSerializer(blogs, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)

    def post(self, request):
        user = request.user
        serializer = BlogSerializer(data=request.data, context={'request': request})
        is_published = request.data.get("is_published") in ["true", "True", True]
        if serializer.is_valid():
            try:
                custom_user = UserAuth.objects.get(id=user.id)
            except UserAuth.DoesNotExist:
                return Response({"Error": "User not found in UserAuth."}, status=400)

            # get display name depending on profile type
            if hasattr(user, 'profile'):
                author_name = user.profile.name
            elif hasattr(user, 'admin_profile'):
                author_name = "Worth Minds"
            else:
                author_name = 'Unknown'

            # print("Auth Type from Token:", getattr(user, 'auth_type_from_token', 'N/A'))

            serializer.save(user=custom_user, author=author_name, is_published=is_published)
            return Response(serializer.data, status=status.HTTP_201_CREATED)

        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class BlogDetailAPIView(APIView):
    authentication_classes = [CustomJWTAuthentication]
    permission_classes = [IsAdminUser]

    def get_object(self, pk):
        return get_object_or_404(Blog, pk=pk)

    def get(self, request, pk):
        blog = self.get_object(pk)
        serializer = BlogSerializer(blog)
        return Response(serializer.data)

    def put(self, request, pk):
        blog = self.get_object(pk)
        serializer = BlogSerializer(blog, data=request.data, context={'request': request})
        is_published = request.data.get("is_published") in ["true", "True", True]
        is_rejected = request.data.get("is_rejected") in ["true", "True", True]
        try:
            if serializer.is_valid():
                with transaction.atomic():
                    blog = serializer.save(is_published=is_published, is_rejected=is_rejected)
                    user = blog.user
                    if hasattr(user, 'profile'):
                        # check if any blog notification exists for the given blog with status accept or reject exists, if yes, update the same blog notification only
                        if is_published:
                            notif, created = BlogNotification.objects.get_or_create(
                                blog=blog,
                                status='accepted',
                                defaults={'user': user}
                            )
                            if not created:
                                notif.is_read = False
                                notif.created_at = timezone.now()
                                notif.save(update_fields=['is_read', 'created_at'])
                        if is_rejected:
                            notif, created = BlogNotification.objects.get_or_create(
                                blog=blog,
                                status='rejected',
                                defaults={'user': user}
                            )
                            if not created:
                                notif.is_read = False
                                notif.created_at = timezone.now()
                                notif.save(update_fields=['is_read', 'created_at'])

                return Response(serializer.data)
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        except DatabaseError as db_err:
            return Response(
                {"error": "A database error occurred while updating the blog.", "details": str(db_err)},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
        except Exception as exc:
            return Response(
                {"error": "An unexpected error occurred while updating the blog.", "details": str(exc)},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    def delete(self, request, pk):
        blog = self.get_object(pk)
        blog.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)


class PublishedBlogPagination(PageNumberPagination):
    page_size = 10
    page_size_query_param = 'page_size'
    max_page_size = 50


class PublishedBlogListAPIView(APIView):
    permission_classes = [AllowAny]

    class CustomPagination(PageNumberPagination):
        page_size = 10
        page_size_query_param = 'page_size'
        max_page_size = 50

    def get(self, request):
        search_query = request.query_params.get("search", "")
        sort_by = request.query_params.get("sort", "-created_at")

        blogs = Blog.objects.filter(is_published=True, is_rejected=False).defer('content')

        # Apply search
        if search_query:
            blogs = blogs.filter(
                Q(title__icontains=search_query) |
                Q(summary__icontains=search_query) |
                Q(author__name__icontains=search_query)  # Optional: adjust based on your model
            )

        # Apply sorting
        allowed_sort_fields = ['created_at', 'title', '-created_at', '-title']
        if sort_by in allowed_sort_fields:
            blogs = blogs.order_by(sort_by)
        else:
            blogs = blogs.order_by('-created_at')  # Default fallback

        paginator = self.CustomPagination()
        result_page = paginator.paginate_queryset(blogs, request)
        serializer = BlogSerializer(result_page, many=True)
        return paginator.get_paginated_response(serializer.data)


class PublishedBlogListAPIViewByTags(APIView):
    permission_classes = [AllowAny]
    authentication_classes = []

    class CustomPagination(PageNumberPagination):
        page_size = 10
        page_size_query_param = 'page_size'
        max_page_size = 50

    def get(self, request):
        tags_param = request.query_params.get("tags", "")
        search_query = request.query_params.get("search", "")
        sort_by = request.query_params.get("sort", "-created_at")

        tag_names = [tag.strip() for tag in tags_param.split(",") if tag.strip()]
        tag_qs = BlogTag.objects.filter(name__in=tag_names)

        blogs = Blog.objects.filter(is_published=True).filter(tags__in=tag_qs).distinct().defer('content')

        # Apply search
        if search_query:
            blogs = blogs.filter(
                Q(title__icontains=search_query) |
                Q(summary__icontains=search_query) |
                Q(author__name__icontains=search_query)
            )

        # Apply sorting
        allowed_sort_fields = ['created_at', 'title', '-created_at', '-title']
        if sort_by in allowed_sort_fields:
            blogs = blogs.order_by(sort_by)
        else:
            blogs = blogs.order_by('-created_at')

        paginator = self.CustomPagination()
        page = paginator.paginate_queryset(blogs, request)
        serializer = BlogSerializer(page, many=True)
        return paginator.get_paginated_response(serializer.data)


class PublishedBlogDetailAPIView(generics.RetrieveAPIView):
    queryset = Blog.objects.filter(is_published=True)
    serializer_class = BlogSerializer  # ✅ Includes content
    permission_classes = [AllowAny]


# user blogs
class UserBlogListCreateAPIView(APIView):
    authentication_classes = [CustomJWTAuthentication]
    permission_classes = [IsAuthenticated]

    def get(self, request):
        user = request.user
        blogs = Blog.objects.filter(user=user).defer('content').order_by('-created_at')
        serializer = BlogSerializer(blogs, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)

    def post(self, request):
        user = request.user
        serializer = BlogSerializer(data=request.data, context={'request': request})
        if serializer.is_valid():
            try:
                custom_user = UserAuth.objects.get(id=user.id)
            except UserAuth.DoesNotExist:
                return Response({"Error": "User not found in UserAuth."}, status=status.HTTP_400_BAD_REQUEST)

            if hasattr(user, 'profile'):
                author_name = user.profile.name
            elif hasattr(user, 'admin_profile'):
                author_name = user.admin_profile.full_name
            else:
                author_name = 'Unknown'

            try:
                with transaction.atomic():
                    # when a contributor creates a blog set the published date to today
                    blog = serializer.save(user=custom_user, author=author_name)
                    BlogNotification.objects.create(
                        user=custom_user,
                        blog=blog,
                        status='pending',
                    )
            except DatabaseError as db_err:
                return Response(
                    {"error": "A database error occurred while creating the blog or notification.", "details": str(db_err)},
                    status=status.HTTP_500_INTERNAL_SERVER_ERROR
                )
            except Exception as exc:
                return Response(
                    {"error": "An unexpected error occurred.", "details": str(exc)},
                    status=status.HTTP_500_INTERNAL_SERVER_ERROR
                )

            return Response(serializer.data, status=status.HTTP_201_CREATED)

        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class UserBlogDetailAPIView(APIView):
    authentication_classes = [CustomJWTAuthentication]
    permission_classes = [IsAuthenticated]

    def get_object(self, pk):
        blog = get_object_or_404(Blog, pk=pk)
        if blog.user != self.request.user:
            raise PermissionDenied("You do not have permission to access this blog.")
        return blog

    def get(self, request, pk):
        blog = self.get_object(pk)
        serializer = BlogSerializer(blog)
        return Response(serializer.data)

    def put(self, request, pk):
        blog = self.get_object(pk)
        serializer = BlogSerializer(blog, data=request.data, context={'request': request})
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    def delete(self, request, pk):
        blog = self.get_object(pk)
        blog.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)


# S3 image manager
class S3ImageManager(APIView):
    parser_classes = (MultiPartParser, FormParser)
    authentication_classes = [CustomJWTAuthentication]
    permission_classes = [IsAuthenticated]
    # permission_classes = [AllowAny]

    def post(self, request):
        """
        Upload an image to a folder.
        Example: POST with 'image' in form-data, optional 'folder'
        """
        image_file = request.FILES.get('image')
        folder = request.data.get('folder', 'cover')

        if not image_file:
            return Response({'error': 'No image file provided'}, status=400)

        bucket = S3_BLOG_BUCKET_NAME
        response = upload_image_to_s3(image_file=image_file, folder=folder, bucket=bucket)

        if not response['error']:
            print('Response message:', response['message'], 'url:', response['url'])
            return Response({'message': response['message'], 'url': response['url'], 'key': response['key']}, status=200)
        
        if response['error']:
            print('Response error message:', response['message'])
            return Response({'message': response['message']}, status=400)
        

    def delete(self, request):
        """
        Delete an image from S3.
        Example: DELETE /api/s3-image/?key=cover/image.jpg
        """
        image_key = request.query_params.get('key')

        if not image_key:
            return Response({'error': 'Image key is required'}, status=400)

        bucket = S3_BLOG_BUCKET_NAME

        response = delete_image_from_s3(bucket=bucket, image_key=image_key)

        if not response['error']:
            print('Response message:', response['message'], image_key)
            return Response({'message':response['message']}, status=200)
        
        if response['error']:
            print('Response error message:', response['message'])
            return Response({'message':response['message']}, status=400)




import boto3
from django.conf import settings
from rest_framework.decorators import api_view, permission_classes
from rest_framework.response import Response
from rest_framework import status

# @api_view(['GET'])
# @permission_classes([AllowAny])
# def get_image_url(request):
#     image_key=request.query_params.get('key')
#     bucket=S3_BLOG_BUCKET_NAME

#     if not image_key:
#         return {'error': 'Image key is required', 'success': False}

#     response = get_image_url(bucket=bucket, image_key=image_key)

#     if not response['error']:
#         print('Response message:', response['message'])
#         return Response({'message':response['message']}, status=200)
    
#     if response['error']:
#         print('Response error message:', response['message'])
#         return Response({'message':response['message']}, status=400)



class ListS3Images(APIView):
    permission_classes = [AllowAny]  # Just for testing

    def get(self, request):
        folder = request.query_params.get('folder', 'cover/')  # default to 'cover/' folder

        s3 = boto3.client(
            's3',
            aws_access_key_id=settings.AWS_ACCESS_KEY_ID,
            aws_secret_access_key=settings.AWS_SECRET_ACCESS_KEY,
            region_name=settings.AWS_S3_REGION_NAME
        )

        bucket_name = settings.AWS_STORAGE_BUCKET_NAME

        try:
            response = s3.list_objects_v2(Bucket=bucket_name, Prefix=folder)
            files = []

            for obj in response.get('Contents', []):
                key = obj['Key']
                # Skip folders
                if not key.endswith('/'):
                    file_url = f"https://{bucket_name}.s3.amazonaws.com/{key}"
                    files.append(file_url)

            return Response({"images": files})
        except Exception as e:
            return Response({"error": str(e)}, status=500)
        